#include "IMRSA.h"


static int IM_RootPubKeyLen[] = {140, 140, 140, 140, 140, 140, 140, 140};

static const char *IM_RootPubKeyData[] = {
        "\x30\x81\x89\x02\x81\x81\x00\xe9\x62\x77\xc6\x97\x78\x58\xc0\x28\xe3\x81\xca\x95\xd5\xb8\x13\x45\x51\xd4\x8b\x6a\xc4\xd2\x2a\xe3\x61"
                "\x10\xac\xe5\x3a\xa5\xa9\x48\xae\x3f\x15\x03\x4c\xd6\xa4\x58\x07\x8f\xb9\x53\x1d\xfb\xf1\x85\xb8\xb5\x94\xf5\x4e\x59\x7a\xf7\xb4"
                "\xbc\x71\x29\x27\xfc\xda\x35\x35\x8b\x42\x7e\x76\x6b\xa7\xa2\x0e\x46\x7e\x5b\x96\xf0\xbf\xa0\x0a\x82\x94\xcf\xe0\x33\x41\x78\x81"
                "\xa0\xf6\x0a\x86\xfc\x17\xeb\xee\xe3\xf4\x98\xa7\x34\x4a\x6f\xde\xab\x72\x66\x42\xa3\xde\xf1\x72\x90\xe7\x90\xfc\x98\xaa\x09\x5d"
                "\x77\xe5\xa2\x1f\xcf\xa9\x02\x03\x01\x00\x01",

        "\x30\x81\x89\x02\x81\x81\x00\xd6\xd6\x09\x3b\x03\xbd\x9b\xe4\x77\x67\xd4\x7a\xce\x0d\xa4\xa5\x39\x14\x41\xcb\x67\x49\x60\xe7\xd3\x8e"
                "\x64\x8e\x10\xa8\x1d\x44\xb2\x56\x72\x94\xb9\xb7\x77\xc0\x22\x7f\xa3\x8c\xaa\xd6\x3d\x45\xc3\x20\x49\x85\xfb\x86\xa3\x58\x4c\x57"
                "\x5a\x09\xd8\x1c\x1a\xdb\xd7\x7c\x4f\x23\x2b\xfd\xb5\xe8\x63\x82\x50\x40\x49\xc7\xef\x4b\x65\xd6\xd1\x73\x4c\xb0\x9b\x7c\xcd\x0c"
                "\x22\x88\xc1\xf2\x13\x59\x97\x1e\xf8\xf5\xed\xb4\x6f\x18\x32\x45\x00\xf9\x6d\xb4\x2f\xa9\xf8\xc4\x2d\x49\x56\xb5\xe0\xc8\x7f\xbc"
                "\x02\x89\xe1\x15\xe4\x29\x02\x03\x01\x00\x01",

        "\x30\x81\x89\x02\x81\x81\x00\xc7\xb9\x63\xb7\xa8\xc5\x43\x4e\xd6\xd1\xac\xb6\xc5\xec\x91\x93\xd1\x0e\x7f\x6e\x13\x44\x91\x46\x74\xb6"
                "\xd3\x80\x68\xe4\x6c\x84\x87\x22\x5c\xda\x05\x2e\x71\xef\xdb\x18\x97\x4d\x5d\x54\x16\x35\xf2\xf8\xc0\xfd\x6b\x7c\xed\xc6\x19\x3d"
                "\x86\x04\x50\xec\x10\x7f\xf6\xac\x1e\x84\x09\x9a\xf2\x9f\xd1\xa2\xfa\xf6\xc2\x15\x53\x71\xb0\x4d\x56\x71\x72\xc7\x90\x59\xfc\xeb"
                "\xd6\xfd\xfb\xe7\xc6\x17\x24\x78\x17\x27\x0d\x6c\x9b\xe4\xfb\x71\x32\x7d\xa6\x24\xa4\xad\xf1\x4e\x58\xbd\xb1\xdf\x31\xbb\x5a\xd5"
                "\x4c\x03\x4f\x49\x89\x3b\x02\x03\x01\x00\x01",

        "\x30\x81\x89\x02\x81\x81\x00\xa9\x16\xf3\xe9\xb7\xb0\x9c\x60\x11\x4c\x93\xaf\x2d\xe1\xa9\x0c\xe0\x85\xc7\x70\x7c\xc8\x21\xd6\x43\xc7"
                "\x09\x9f\x61\xcc\xd3\x78\xaa\x05\xea\x54\x3d\xbe\x97\x00\xa5\x02\x9a\x4c\x63\x2e\x71\x58\x3b\x9a\x81\x3f\x22\x8c\x4a\x7d\xcc\x03"
                "\xda\xfd\x27\x60\x72\x08\x9a\xa2\x5f\xff\xff\x84\xc4\x27\x35\xba\xeb\xc6\xb1\x5f\x95\xf2\x29\xde\xb9\x9c\x6d\xa7\x7a\x3f\xe2\x43"
                "\xfd\xc4\x2f\x7c\x15\xfc\x10\x45\x4c\x9a\x92\x2f\xc7\xa0\x71\x80\x65\xe7\x30\x32\x00\xbe\xa3\xbd\xc7\x84\xec\xeb\xcd\xcc\xe1\x9a"
                "\x78\xc6\xae\xcb\xa4\x2d\x02\x03\x01\x00\x01",

        "\x30\x81\x89\x02\x81\x81\x00\xb7\x29\x47\x9c\x26\xfa\x48\x33\x59\xb3\x40\xd8\xaf\xb8\xcf\xb4\x84\x67\x46\x04\x02\x1a\x25\x70\x92\x9a"
                "\x78\x7c\xab\x8d\x99\x11\xc8\xfd\x1c\xd0\xe2\x46\xdb\x57\xc6\x1b\x00\xec\x6d\x73\xae\x93\xdf\xec\xf0\x9e\xdb\x99\x7b\xe7\x0b\x7b"
                "\x14\x60\x6f\x6f\xad\xed\x96\xd4\x10\xe3\x23\x81\x99\xf3\x71\x51\x98\xaa\xc5\xee\xf5\x5d\x3e\x45\xb3\x50\x55\x18\xb0\x6a\x2b\xd5"
                "\x1c\xb0\x9a\x1d\xb7\x65\x0b\x14\xe3\x3d\xdf\x6b\x78\x22\xc2\x73\x79\x65\x0b\xe7\x07\x89\xbd\xe1\xe8\xaf\x8c\xc5\xa0\x4c\x51\xf2"
                "\x2e\x43\x6b\x4a\xe6\x71\x02\x03\x01\x00\x01",

        "\x30\x81\x89\x02\x81\x81\x00\xd4\x2f\xd2\x9c\x9b\x7e\x6f\x9c\xbc\x93\x58\x25\x01\xf4\x51\xc7\xfd\x02\x28\x2b\x94\x7e\xa4\xb4\x9c\xc7"
                "\x78\x57\xcd\xe4\x43\x4c\xcd\x85\x5a\xf8\x2c\xd2\x31\x6d\x00\x5e\x20\xe9\xb6\x8c\x42\x7f\xa1\xcb\x29\xa8\xfd\xe2\xe8\xa8\xfa\x3c"
                "\x09\x24\xf0\xe9\x43\xad\xf6\x19\xef\xc2\x74\xc5\xc0\x74\x26\xf0\x03\x76\x63\x28\x7c\x6b\x14\x6f\xf9\x07\x0e\x4e\x66\x31\x72\xdd"
                "\x0d\x7d\x39\xcf\x80\x80\x00\xcf\x2a\xf9\xc9\x14\x06\xfa\xb6\x63\x49\x2b\x04\x0d\x59\x67\x28\x79\x60\x96\xef\x5c\x44\xe5\xbb\x0d"
                "\x57\x48\x16\x9b\x44\x4d\x02\x03\x01\x00\x01",

        "\x30\x81\x89\x02\x81\x81\x00\xba\x2d\xdf\x31\xa2\x00\x56\x27\x93\x5f\xe0\x91\xca\x57\xce\xe5\x33\x33\x4d\xee\x5f\x2c\x2c\xa6\xf8\x15"
                "\xc6\xab\x56\x3f\x28\x5f\x52\xd1\xdb\x83\x2a\x63\x6a\x6f\xf7\xd9\xbc\xad\xc1\x2a\x8c\x40\x2b\x1a\x80\x0c\x0d\x90\x83\xdb\x90\x77"
                "\x56\xaa\x30\x2f\xf9\x34\x4f\x64\x00\x09\xb8\x1e\x1e\x20\x77\x68\x2a\x10\x20\x18\x17\x6f\x88\xd8\xf3\x3a\x18\x25\xca\x3c\x3f\x74"
                "\x9d\x1f\x04\x2d\x67\x99\xc8\xbe\x88\xb5\xe3\xe4\xce\xe6\x4d\x85\x56\xc9\xff\x27\x17\x9f\x2e\xa5\xc4\xe8\x2b\x74\x5c\xba\x82\x70"
                "\xc6\x93\xc9\xcd\xf7\x07\x02\x03\x01\x00\x01",

        "\x30\x81\x89\x02\x81\x81\x00\xb7\x8e\x1a\xab\xc1\xbc\x40\xb4\x4d\xad\x99\x62\x6f\x7d\xf0\x55\xf1\x3c\xa6\x4d\x87\xf9\x2b\x0e\x31\x58"
                "\x54\x7e\xa2\x4f\xaa\x0e\xcc\x98\x13\x3e\x8f\xeb\xbd\x30\xbd\x46\xe5\x2c\x82\x6a\x60\x8b\x97\x6d\x42\x2f\xf5\x66\x25\xe3\xa7\xb1"
                "\x65\xe2\xab\x04\x93\x1e\x1f\x54\xbd\xd6\xf4\x32\xbe\x8e\x09\xda\x9b\x6b\xf0\xe4\x6b\x6b\xa4\x40\xab\x42\x35\x74\xdb\x65\x24\x25"
                "\x1b\xb8\x01\x66\xa3\x58\x4f\x75\x1f\xf6\xf8\x57\xd5\x94\xec\x52\x35\xe5\x3f\xa3\xf9\x0e\x63\x9b\x17\x80\x59\x24\xd0\x29\x15\xb9"
                "\xc6\x8a\xde\x44\xdd\x65\x02\x03\x01\x00\x01"
};


int IMRSA::InitRK() {

    for (int i = 0; i < MAX_RSA_ROOT_KEY; i++) {
        int keyLen = IM_RootPubKeyLen[i];
        char *pubKeyDataCopy = new char[keyLen];
        memcpy(pubKeyDataCopy, IM_RootPubKeyData[i], keyLen);
        m_pRootKey[i] = d2i_RSAPublicKey(NULL, (const unsigned char **) &(pubKeyDataCopy), keyLen);
    }

    BIGNUM *pOneBN = BN_new();
    m_pS3Key = RSA_new();

    BN_set_word(pOneBN, RSA_F4);
    RSA_generate_key_ex(m_pS3Key, RSA_KEY_LEN, pOneBN, NULL);


    unsigned char *pPubData = NULL, *pPrvData = NULL;
    m_nS3KeyPubDataLen = i2d_RSAPublicKey(m_pS3Key, &pPubData);
    m_nS3KeyPrvDataLen = i2d_RSAPrivateKey(m_pS3Key, &pPrvData);
    memcpy(m_szS3KeyPubData, pPubData, m_nS3KeyPubDataLen);
    memcpy(m_szS3KeyPrvData, pPrvData, m_nS3KeyPrvDataLen);
    OPENSSL_free(pPubData);
    OPENSSL_free(pPrvData);
    BN_free(pOneBN);


    return 0;
}

int IMRSA::LeaveRK() {
    for (int i = 0; i < MAX_RSA_ROOT_KEY; i++) {
        if (NULL != m_pRootKey[i]) {
            RSA_free(m_pRootKey[i]);
            m_pRootKey[i] = NULL;
        }
    }

    return 0;
}

IMRSA::IMRSA() {
    m_pS2Key = NULL;
    m_pS3Key = NULL;
    m_paKey = NULL;

    InitRK();
}

IMRSA::~IMRSA() {
    if (NULL != m_pS2Key) {
        RSA_free(m_pS2Key);
    }
    if (NULL != m_pS3Key) {
        RSA_free(m_pS3Key);
    }
    if (NULL != m_paKey) {
        RSA_free(m_paKey);
    }

    LeaveRK();

}

int IMRSA::saveS2Data(int nRootKey, int nRootKeyLen, const unsigned char *p, int nlen) {
    if (nRootKey <= 7 && nRootKey > 0) {
    }

    unsigned char szData[4096] = {0};
    unsigned int nDataLen = 0;
    unsigned char *pKey = szData;
    int nT = nRootKeyLen / 8;

    for (int i = 0; i < nlen / nT; i++) {
        int nCRet = RSA_public_decrypt(nT, p + i * nT, szData + nDataLen, m_pRootKey[nRootKey], RSA_PKCS1_PADDING);
        if (nCRet == -1) {
            return -1;
        }
        nDataLen += nCRet;
    }

    m_pS2Key = d2i_RSAPublicKey(NULL, (const unsigned char **) &pKey, nDataLen);
    if (NULL == m_pS2Key) {
        return -1;
    }

    return 0;
}

int IMRSA::getS3Data(unsigned char **p, int *nlen) {
    //int nlen = 0;
    int nK = 100;
    int nT = RSA_KEY_LEN / 8;
    int nRetLen = 0;
    unsigned char *pRet = (unsigned char *) malloc(RSA_ENCRYPT_BUFF_LEN);
    int i = 0;

    for (i = 0; i < 140 / nK; i++) {

        int nCRet = RSA_public_encrypt(nK, m_szS3KeyPubData + i * nK, pRet + i * nT, m_pS2Key, RSA_PKCS1_PADDING);


        if (nCRet == -1) {
            free(pRet);
            return -1;
        }

        nRetLen += nCRet;
    }

    int nR = 140 % nK;
    if (nR != 0) {
        int nCRet = RSA_public_encrypt(nR, (const unsigned char *) m_szS3KeyPubData + i * nK, pRet + i * nT, m_pS2Key, RSA_PKCS1_PADDING);


        if (nCRet == -1) {
            free(pRet);
            return -1;
        }

        nRetLen += nCRet;
    }

    *nlen = nRetLen;
    *p = pRet;

    return 0;
}

int IMRSA::saveS4Data(const unsigned char *p, int nlen) {
    int nDataLen = 0;
    unsigned char szData[4096] = {0};
    int nT = RSA_KEY_LEN / 8;

    int i;
    for (i = 0; i < nlen / nT; i++) {
        int nCRet = RSA_private_decrypt(nT, p + i * nT, szData + nDataLen, m_pS3Key, RSA_PKCS1_PADDING);
        if (nCRet == -1) {
            return -1;
        }
        nDataLen += nCRet;
    }


    if (nDataLen > MAX_SYM_KEY_LEN) {
        return -1;
    }

    memcpy(m_szSynKey, szData, nDataLen);
    AES_set_encrypt_key(m_szSynKey, nDataLen * 8, &m_EKey);
    AES_set_decrypt_key(m_szSynKey, nDataLen * 8, &m_DKey);
    return 0;
}


int IMRSA::aesDecrptData(const unsigned char *pSrc, unsigned iLenSrc, unsigned char *pDst, unsigned *lenDest) {
    unsigned int iBlocks = iLenSrc / AES_BLOCK_SIZE;

    for (unsigned int i = 0; i < iBlocks; i++) {
        AES_decrypt(pSrc, pDst, &m_DKey);
        pSrc += AES_BLOCK_SIZE;
        pDst += AES_BLOCK_SIZE;
    }

    *lenDest = iLenSrc;

    return 0;
}


int IMRSA::aesEncrptData(const unsigned char *pSrc, unsigned lenSrc, unsigned char *pDst, unsigned *lenDest) {
    unsigned int iBlocks = lenSrc / AES_BLOCK_SIZE;
    unsigned int iRemainder = lenSrc % AES_BLOCK_SIZE;

    for (unsigned int i = 0; i < iBlocks; i++) {
        AES_encrypt(pSrc, pDst, &m_EKey);
        pSrc += AES_BLOCK_SIZE;
        pDst += AES_BLOCK_SIZE;
    }

    if (iRemainder != 0) {
        char pTmpBuff[AES_BLOCK_SIZE] = {0};    //
        memcpy(pTmpBuff, pSrc, iRemainder);
        AES_encrypt((const unsigned char *) pTmpBuff, pDst, &m_EKey);
        iBlocks++;
    }

    *lenDest = iBlocks * AES_BLOCK_SIZE;

    return 0;
}



